# 요구사항 확인
## 소프트웨어 생명주기 (Software Development Life Cycle)
- 시스템의 __요구분석부터 유지보수까지 전 공정을 체계화한 절차__

### 프로세스
- 설계 : __논리적으로 결정하는 단계__
- 유지보수 : __시스템이 인수되고 설치된 후 일어나는 모든 활동__

### 모델 종류
- 폭포수 모델 : 개발 시 __각 단계를 확실히 마무리 지은 후__ 에 다음 단계로 넘어감, __선형 순차적 모델__ 
- 프로토타이핑 모델 : __프로토타입으로 구현, 고객의 피드백__ 반영
- 나선형 모델 : __위험을 최소화__ 하기 위해 점진적으로 완벽하게 개발해 나가는 모델
- 반복적 모델 : 구축대상을 __병렬적으로 개발__ 후 통합

## 소프트웨어 개발방법론
- 소프트웨어 개발 전 과정에 __지속적으로 적용__ 할 수 있는 방법, 절차, 기법

### 방법론 종류
- 구조적 방법론 (SD) : __기능__ 에 따라 나누어 개발, __분할과 정복__ 접근 방식, __나씨-슈나이더만 차트__ 
  - 나씨-슈나이더만 차트 특징 : 논리의 기술에 중점을 둔 __도형식 표현 방법__ 
- 객체지향 방법론 (OOD) : __'객체'라는 기본 단위__
- 컴포넌트 기반 방법론 (CBD) : __컴포넌트를 조립__
- 애자일 방법론 : __사람이 중심__
  - XP : 1~3주의 반복 개발주기
  - XP의 5가지 가치 : 용기, 단순성, 의사소통, 피드백, 존중
  - XP의 12가지 기본원리 : 
    - 짝 프로그래밍 : 개발자 __둘이서 짝으로__ 코딩
    - 공동 코드 소유 : 시스템에 있는 코드는 __누구든지 언제라도 수정__ 가능
    - 지속적인 통합 (CI) : 매일 여러 번씩 소프트웨어를 통합하고 빌드
    - 계획 세우기 : 고객이 요구하는 비즈니스 가치 정의, 개발자가 필요한 것, 어느 부분에서 지연되는지 알려주어야 함
    - 작은 릴리즈 : 작은 시스템 먼저 제작, 짧은 단위로 업데이트
    - 메타포어 : 공통적인 이름 체계와 시스템 서술서, 원활한 의사소통
    - 간단한 디자인 : 요구사항에 적합한 가장 단순한 시스템 설계
    - 테스트 기반 개발 : 테스트 먼저 수행, 통과 시 실제 프로그램 작성
    - 리팩토링 : 기능을 바꾸지 않으면서 중복제거, 단순화 등 
    - 40시간 작업 : 주 당 40시간 이상 작업 금지
    - 고객 상주 : 개발자의 질문에 즉각적으로 대답 가능한 고객 상주
    - 코드 표준 : 코딩 표준을 정의해야 함
  - 스크럼 : 매일 정해진 시간, 장소에서 짧은 시간의 개발
    - 백로그 : 제품과 프로젝트에 대한 요구사항
    - 스프린트 : 2~4주의 짧은 개발 기간, 반복적 수행
    - 스크럼 미팅 : 매일 15분 정도 미팅
    - 스크럼 마스터 : 프로젝트 리더, 문제를 인지 및 해결하는 사람
    - 스프린트 회고 : 규칙 준수 여부, 개선점 등 확인 및 기록
    - 번 다운 차트 : 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트
  - 린 : 도요타의 린 시스템 품질기법

## 비용산정 모형
### 분류
- 하향식 산정기법 : 경험이 많은 전문가에게 의뢰 (델파이)
- 상향식 산정기법 : 세부적인 요구사항과 기능에 따라 비용 계산 (Loc, Man Month, COCOMO 등)

### 종류
- Man Month : 한 사람이 1개월간 할 수 있는 일의 양
  - Loc / 프로그래머의 월간 생산성
  - 프로젝트 기간 : Man Month / 프로젝트 인력
- COCOMO : 보헴이 제안
- 푸트남 모형 : Rayleigh-Norden 곡선의 노력 분포도
- 기능점수 모형 (FP) : 인자별로 가중치 부여, 가중치 합산

## 일정관리 모델
### 종류
- 주 공정법 (Critical Path Method) : 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 방법 (임계 경로 : 가장 긴 시간 소요)
- PERT : 비관치, 중간치, 낙관치

## 소프트웨어 아키택처
- 외부에 드러나는 특성, 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체

### 소프트웨어 아키텍처 4+1 뷰
- 유스케이스 뷰 : 다른 뷰를 검증하는 데 사용
- 논리 뷰 : 기능적인 요구사항
- 프로세스 뷰 : 비기능적인 요구사항
- 구현 뷰
- 배포 뷰

### 소프트웨어 아키텍처 패턴 유형
- 계층화 패턴 : 시스템을 계층으로 구분하여 구성
- 클라이언트-서버 패턴 : 클라이언트-서버
- 파이프-필터 패턴 : 데이터 스트림
- 브로커 패턴 : 분산 시스템
- MVC 패턴 : 대화형 애플리케이션

## 디자인 패턴
- 공통적으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴

### 종류
#### 생성 패턴
- Builder : 복잡한 인스턴스를 조립하여 만드는 구조
- Prototype : 원형을 복사하여 필요한 부분만 수정하여 사용
- Factory Method : 오버라이딩
- Abstact Factory : 구체적인 클래스에 의존하지 않음
- Singleton : 전역 변수를 사용하지 않음
#### 구조 패턴
- Bridge : 기능 클래스와 구현 클래스 연결. 추상화된 부분 변경 필요시 활용
- Decorator : 객체의 결합을 통해 기능을 동적으로 유연하게 확장
- Facade : 복잡한 시스템에 단순한 인터페이스 제공
- Flyweight : 클래스 경량화 목적
- Proxy : 실체 객체에 대한 대리 객체
- Composite : 객체들의 관계를 트리 구조로 구성, 부분-전체 계층 표현
- Adapter : 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
#### 행위 패턴
- Mediator : 중재자 역할
- Interpreter : 문법 자체를 캡슐화하여 사용
- Iterator : 내부를 노출시키지 않고 안에 들어있는 항목에 접근할 방법 예고
- Template Method : 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분 수행
- Observer : 다른 객체들에 연락, 느슨하게 결합하는 디자인 패턴
- State : 객체의 상태에 따라 행위 내용 변경
- Visitor : 객체의 구조 변경 X, 기능만 따로 추가하거나 확장할 때 사용
- Command : 요구사항을 객체로 캡슐화
- Strategy : 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환 
- Memento : Undo 기능 요청 가능
- Chain of Responsibility : 한 요청을 2개 이상의 객체에서 처리




















